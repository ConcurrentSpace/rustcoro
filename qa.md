## 为什么我用这种方式导入汇编，必须要用 intel 语法？

使用 global_asm! 宏导入汇编时，Rust 默认使用 Intel 语法的原因如下：

LLVM 后端的默认选择

Rust 使用 LLVM 作为其后端
LLVM 的内联汇编默认使用 Intel 语法
这是为了保持与 LLVM 的一致性
语法一致性

Rust 的 asm! 宏也使用 Intel 语法
保持 global_asm! 和 asm! 的语法一致性，降低学习成本
不过，你可以显式指定使用 AT&T 语法，方法是：

```asm
.att_syntax
.global gt_switch
.section .text

gt_switch:
    mov (%rdi), %rsp
    ret
```

text
对比两种语法的区别：

特性	Intel 语法	AT&T 语法
操作数顺序	mov dest, src	mov src, dest
寄存器命名	rax	%rax
立即数	42	$42
内存引用	[rax]	(%rax)
选择建议：

如果使用 global_asm!：优先使用 Intel 语法
如果使用 build.rs：两种语法都可以，但要保持一致

## 理解 Context

这个 `Context` 结构体定义了在 x86_64 架构上进行协程上下文切换时需要保存和恢复的寄存器集合。这些寄存器分为几个关键类别，我来详细解释每个寄存器的作用：

### 核心寄存器

1. **rsp (Stack Pointer)**
   - 栈指针寄存器，指向当前栈顶位置
   - 每个协程有自己的栈空间，切换时必须保存/恢复
   - 确保协程恢复后能继续使用自己的栈

2. **rbp (Base Pointer)**
   - 基指针寄存器，用于访问栈帧中的局部变量和参数
   - 维护函数调用栈的结构
   - 在调试和栈回溯中特别重要

3. **rip (Instruction Pointer)**
   - 指令指针寄存器，指向下一条要执行的指令
   - 协程挂起时保存当前位置
   - 协程恢复时从此位置继续执行

### Callee-Saved 寄存器（被调用者保存）

这些寄存器在函数调用中必须由被调用者保存：

4. **rbx (Base Register)**
   - 通用寄存器，常用于存储基地址或计算
   - 在循环和数组操作中常用

5. **r12, r13, r14, r15**
   - 额外的通用寄存器
   - 编译器常用它们存储跨函数调用的值
   - 需要保存以确保协程恢复后计算状态一致

### 为什么选择这些寄存器？

在 x86_64 调用约定中：
- **Callee-saved 寄存器**：被调用函数必须保存这些寄存器（rbx, rbp, r12-r15）
- **Caller-saved 寄存器**：调用函数负责保存（rax, rcx, rdx, rsi, rdi, r8-r11）

我们的上下文切换只保存 Callee-saved 寄存器，因为：
1. **效率**：减少保存/恢复的寄存器数量
2. **约定遵守**：切换函数遵循标准调用约定
3. **必要性**：Caller-saved 寄存器可通过编译器自动处理

### 上下文切换时的寄存器处理流程

1. **保存当前上下文**：
   ```nasm
   mov [rdi + 0], rsp   ; 保存栈指针
   mov [rdi + 8], rbp   ; 保存基指针
   mov [rdi + 16], rbx  ; 保存rbx
   ... ; 保存其他寄存器
   lea rax, [rsp + 8]   ; 计算返回地址
   mov [rdi + 56], rax  ; 保存指令指针
   ```

2. **恢复新上下文**：
   ```nasm
   mov rsp, [rsi + 0]   ; 恢复栈指针
   mov rbp, [rsi + 8]   ; 恢复基指针
   mov rbx, [rsi + 16]  ; 恢复rbx
   ... ; 恢复其他寄存器
   jmp [rsi + 56]       ; 跳转到保存的指令位置
   ```

### 为什么需要完整的上下文保存？

1. **状态完整性**：确保协程恢复后计算状态完全一致
2. **栈隔离**：每个协程有自己的栈空间（rsp）
3. **执行连续性**：rip 保证从正确位置继续执行
4. **函数调用兼容**：rbp 维护调用栈结构
5. **寄存器一致性**：保留跨函数调用的寄存器值

这个寄存器集合构成了协程的最小完整执行环境，保存了足够的状态信息，使协程能够在任意点挂起和恢复，同时保持计算状态的完整性。